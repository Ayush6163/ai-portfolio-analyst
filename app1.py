# ===========================
# AI Portfolio Analyst — Full MVP
# By: A. Aryan
# ===========================
# Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass // code to run this file 1 
# # python -m streamlit run app.py // then this 2 to run and open the file.

import streamlit as st  # type: ignore
import yfinance as yf  # type: ignore
import pandas as pd  # type: ignore
import numpy as np  # type: ignore
from datetime import date, timedelta
from yahooquery import search  # type: ignore

st.set_page_config(page_title="AI Portfolio Analyst", layout="wide")
st.title("AI Portfolio Analyst — By: A. Aryan")

# ---------------------------
# Helpers
# ---------------------------
@st.cache_data(show_spinner=False)
def fetch_prices(tickers_list, start, end):
    """Download adjusted close prices; works for 1 or many tickers."""
    raw = yf.download(tickers_list, start=start, end=end, auto_adjust=True, progress=False)
    if raw is None or len(raw) == 0:
        return pd.DataFrame()

    if isinstance(raw.columns, pd.MultiIndex):
        # Multi-asset: columns like ('Close','AAPL'), ('Close','MSFT'), ...
        if "Close" not in raw.columns.get_level_values(0):
            return pd.DataFrame()
        close = raw["Close"].copy()
    else:
        # Single asset: columns like Open, High, Low, Close, Volume
        if "Close" not in raw.columns:
            return pd.DataFrame()
        close = raw[["Close"]].copy()
        # Give the column the ticker name
        if isinstance(tickers_list, (list, tuple)) and len(tickers_list) == 1:
            colname = tickers_list[0]
        else:
            colname = "ASSET"
        close.columns = [colname]
    # Clean
    close = close.dropna(how="all")
    return close

def names_to_tickers(names_csv: str):
    """Convert 'Tesla, Amazon' to ['TSLA','AMZN'] using yahooquery search."""
    tickers = []
    for raw in [n.strip() for n in names_csv.split(",") if n.strip()]:
        try:
            res = search(raw)
            quotes = res.get("quotes", [])
            best = None
            for q in quotes:
                if q.get("symbol") and q.get("quoteType") in ("EQUITY", "ETF"):
                    best = q
                    break
            if best:
                tickers.append(best["symbol"])
        except Exception:
            # ignore failed lookups
            pass
    return tickers

def annualize(r: pd.Series):
    mu = r.mean() * 252
    vol = r.std() * np.sqrt(252)
    sharpe = (mu / (vol if vol != 0 else np.nan))
    return mu, vol, sharpe

def build_html_report(title: str, tickers_list, start, end, metrics_df: pd.DataFrame, notes: list[str]):
    """Return a minimal HTML report (no external deps)."""
    tl = ", ".join(tickers_list)
    rows = "\n".join(
        f"<tr><td>{m}</td><td style='text-align:right'>{p}</td><td style='text-align:right'>{b}</td></tr>"
        for m, p, b in metrics_df.values
    )
    notes_html = "".join(f"<li>{n}</li>" for n in notes) if notes else "<li>Portfolio looks balanced for the sample period.</li>"
    return f"""
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>{title}</title>
<style>
body {{ font-family: Arial, sans-serif; margin: 24px; }}
h1, h2, h3 {{ margin: 0.4em 0; }}
table {{ border-collapse: collapse; width: 100%; margin-top: 12px; }}
td, th {{ border: 1px solid #ddd; padding: 8px; }}
th {{ background: #f5f5f5; text-align: left; }}
.small {{ color: #555; }}
</style>
</head>
<body>
<h1>{title}</h1>
<p class="small"><strong>Tickers:</strong> {tl} &nbsp; | &nbsp; <strong>Period:</strong> {start} → {end}</p>

<h2>Key Metrics</h2>
<table>
<tr><th>Metric</th><th>Portfolio</th><th>Benchmark</th></tr>
{rows}
</table>

<h2>Analyst Notes</h2>
<ul>
{notes_html}
</ul>

<p class="small">Report generated by AI Portfolio Analyst (Streamlit).</p>
</body>
</html>
""".strip()


# ---------------------------
# State + Inputs
# ---------------------------
if "tickers_text" not in st.session_state:
    st.session_state["tickers_text"] = "AAPL,MSFT,GOOGL"

colA, colB = st.columns([1, 1])
with colA:
    st.subheader("Search by company name (optional)")
    names = st.text_input("Company names (comma-separated)", "", placeholder="Tesla, Amazon, Nvidia")
    if st.button("Find Tickers"):
        found = names_to_tickers(names)
        if found:
            st.session_state["tickers_text"] = ",".join(found)
            st.success(f"Found: {', '.join(found)} — inserted below.")
        else:
            st.warning("No tickers found. Try different words or type symbols directly.")

with colB:
    st.subheader("Or enter tickers directly")
    tickers_csv = st.text_input("Tickers (comma-separated)", key="tickers_text").upper().replace(" ", "")

col1, col2, col3 = st.columns([1, 1, 1])
with col1:
    start = st.date_input("Start date", date.today() - timedelta(days=365*3))
with col2:
    end = st.date_input("End date", date.today())
with col3:
    benchmark = st.text_input("Benchmark", value="^GSPC", help="Examples: ^GSPC (S&P 500), ^NSEI (Nifty 50)")

go = st.button("Fetch & Analyze", type="primary")

# ---------------------------
# Main
# ---------------------------
if go:
    tickers_list = [t for t in tickers_csv.split(",") if t]
    if not tickers_list:
        st.error("Please enter at least one ticker.")
        st.stop()

    # prices
    close = fetch_prices(tickers_list, start, end)
    if close.empty:
        st.error("No price data returned. Check tickers or date range.")
        st.stop()

    st.markdown("### Raw Close Prices (head)")
    st.dataframe(close.head(), use_container_width=True)

    # Charts
    st.markdown("### Price Chart (Close)")
    st.line_chart(close)

    rets = close.pct_change().dropna()
    st.markdown("### Daily Returns")
    st.line_chart(rets)

    cum = (1 + rets).cumprod()
    st.markdown("### Cumulative Returns (Growth of 1)")
    st.line_chart(cum)

    # Weights
    st.markdown("### Portfolio Weights")
    weights_in = st.text_input(
        "Weights (comma-separated, blank = equal weights)",
        value="",
        help=f"For {len(tickers_list)} tickers. Example: 0.5,0.3,0.2",
    )

    if weights_in.strip():
        try:
            w = np.array([float(x) for x in weights_in.split(",")], dtype=float)
            if len(w) != len(tickers_list):
                st.error(f"Number of weights ({len(w)}) must equal number of tickers ({len(tickers_list)}).")
                st.stop()
            w = w / (w.sum() if w.sum() != 0 else 1.0)
        except Exception as e:
            st.error(f"Could not parse weights: {e}")
            st.stop()
    else:
        w = np.repeat(1 / len(tickers_list), len(tickers_list))

    # Portfolio & benchmark returns
    port_ret = rets @ w

    bench_close = fetch_prices([benchmark], start, end)
    if bench_close.empty:
        st.warning("Benchmark data unavailable; metrics will show only portfolio.")
        bench_ret = pd.Series(0.0, index=port_ret.index)
    else:
        bench_close = bench_close.iloc[:, 0]
        bench_ret = bench_close.pct_change().dropna().reindex(port_ret.index).fillna(0)

    # Metrics
    mu, vol, sharpe = annualize(port_ret)
    bmu, bvol, bsh = annualize(bench_ret)

    equity = (1 + port_ret).cumprod()
    bench_eq = (1 + bench_ret).cumprod()
    mdd = ((equity / equity.cummax()) - 1).min()

    beta = float(np.cov(port_ret, bench_ret)[0, 1] / (bench_ret.var() + 1e-12)) if bench_ret.var() != 0 else np.nan

    alpha = 0.95
    sorted_r = np.sort(port_ret.values)
    idx = max(1, int((1 - alpha) * len(sorted_r)))
    VaR = -sorted_r[idx] if len(sorted_r) > idx else np.nan
    CVaR = -sorted_r[:idx].mean() if idx > 0 else np.nan

    # Show metrics
    st.markdown("### Key Metrics")
    metrics = pd.DataFrame({
        "Metric": ["Ann. Return", "Ann. Vol", "Sharpe", "Beta", "Max Drawdown", "VaR (95%)", "CVaR (95%)"],
        "Portfolio": [f"{mu:.2%}", f"{vol:.2%}", f"{sharpe:.2f}", f"{beta:.2f}", f"{mdd:.2%}", f"{VaR:.2%}", f"{CVaR:.2%}"],
        "Benchmark": [f"{bmu:.2%}", f"{bvol:.2%}", f"{bsh:.2f}", "-", "-", "-", "-"]
    })
    st.dataframe(metrics, use_container_width=True)

    # Rolling vol & Correlation
    st.markdown("### Rolling Volatility (annualized, 21d)")
    roll_vol = port_ret.rolling(21).std() * np.sqrt(252)
    st.line_chart(roll_vol)

    st.markdown("### Correlation Between Assets")
    corr_tbl = rets.corr()
    st.dataframe(corr_tbl.style.format("{:.2f}"), use_container_width=True)

    # Risk contribution
    st.markdown("### Risk Contribution by Asset")
    cov = rets.cov() * 252
    cov_values = cov.values
    sigma = float(np.sqrt(w @ cov_values @ w) + 1e-12)
    mrc = (cov_values @ w) / sigma
    rc = w * mrc
    rc_pct = (rc / (rc.sum() if rc.sum() != 0 else 1.0)) * 100
    rc_df = pd.DataFrame({"Ticker": close.columns, "Weight": w, "Risk Contribution (%)": rc_pct})
    st.dataframe(rc_df.style.format({"Weight": "{:.2%}", "Risk Contribution (%)": "{:.2f}"}), use_container_width=True)
    st.bar_chart(rc_df.set_index("Ticker")["Risk Contribution (%)"])

    # Analyst narrative
    st.markdown("### Analyst Note")
    notes = []
    try:
        if vol > bvol * 1.1:
            notes.append("Portfolio volatility is notably above the benchmark; consider adding low-beta/defensive assets.")
        if sharpe < bsh:
            notes.append("Risk-adjusted performance trails the benchmark; review weights or factor exposure.")
        if float(mdd) < -0.25:
            notes.append("Historical max drawdown exceeded 25%; think about drawdown controls or hedges.")
        if CVaR is not np.nan and CVaR > 0.04:
            notes.append("Tail risk (CVaR) > 4%; reduce concentration or add diversification/hedges.")
        if len(notes) == 0:
            notes.append("Portfolio risk/return profile looks balanced relative to the benchmark for this period.")
    except Exception:
        notes.append("Insufficient data to form a detailed note.")
    for n in notes:
        st.write("• " + n)

    # Downloads
    st.markdown("### Downloads")
    # CSV of portfolio daily returns
    st.download_button(
        "Download portfolio daily returns (CSV)",
        pd.DataFrame({"date": port_ret.index, "portfolio_return": port_ret.values}).to_csv(index=False).encode(),
        file_name="portfolio_returns.csv",
        mime="text/csv",
    )

    # HTML report
    report_html = build_html_report(
        title="AI Portfolio Analyst — Summary Report",
        tickers_list=tickers_list,
        start=str(start),
        end=str(end),
        metrics_df=metrics,
        notes=notes,
    )
    st.download_button(
        "Download Summary Report (HTML)",
        data=report_html.encode("utf-8"),
        file_name="portfolio_report.html",
        mime="text/html",
    )

    st.success("Analysis complete. You can tweak weights, change dates, or try other tickers anytime.")